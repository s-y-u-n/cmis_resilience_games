# sim_contribution design v1

このファイルは、チーム編成シミュレーション `sim_contribution` のアルゴリズム設計書（v1）です。

## 目的

研究部署に所属する `n` 人（プレイヤー）を、各期 `t=1..T` にチームサイズ1–3で編成する。  
編成アルゴリズムとして UD設計・DU設計・Random設計の3方式を用意し、以下を評価する。

- A: 部署総成果（真の期待成果 `mu` に基づく）
- B: Oracle regret（真の `mu` を知る最適編成との差）
- C: 採用チーム成果 `mu(S)` の分布（低成果チームの多発／突出チームの発生をプロットで定性的評価）

観測は「その期に採用したチームの成果」のみを観測し、さらに個人（単体）成果は毎期全員分を観測する。  
未観測の「S と単体の比較」は 0カウント（更新しない）。

## モデル定義

### プレイヤー集合

- `N = {1,2,…,n}`

### 候補提携集合（チーム候補）

- `X = { S ⊆ N : 1 ≤ |S| ≤ 3 }`

### 真の期待成果 mu(S)

#### 個人能力

- 各 `i∈N` に個人能力 `a_i` を与える。

#### 2次相性（ペア相性）

- 各 `i<j` に相性 `b_ij` を与える（正負あり）。
- `b_ji=b_ij` とする。

#### 調整コスト cost(S)

- 各 `i∈N` に協調性パラメータ `c_i`（[0,1]）を与える。
- `cost({i}) = 0`
- `cost(S)`（`|S|≥2`）：

```
cost(S) = Σ_{i<j, i,j∈S} max(0, 1 − (c_i + c_j)/2)
```

#### スキル補完性 comp(S)

- 各 `i∈N` にスキルベクトル `s_i ∈ R^d` を与える。
- 正規化：`s_i := s_i / ||s_i||`（ゼロベクトル禁止）
- `comp({i}) = 0`
- `comp(S)`（`|S|≥2`）：

```
comp(S) = (1 / C(|S|,2)) * Σ_{i<j, i,j∈S} (1 − cos(s_i, s_j))
```

（正規化済みなので `cos(u,v)=u·v`）

#### 期待成果

- `mu({i}) = a_i`
- `mu({i,j}) = a_i + a_j + b_ij + comp({i,j}) − cost({i,j})`
- `mu({i,j,k}) = a_i + a_j + a_k + (b_ij + b_ik + b_jk) + comp({i,j,k}) − cost({i,j,k})`

## 観測モデル

各期 `t` について、乱数ノイズ `ε_t(S)` を用意し、

```
y_t(S) = mu(S) + ε_t(S)
```

観測ルール：

- チーム成果：その期に採用されたチーム集合 `X_t` のみ `y_t(S)` を観測する（`S∈X_t`）。
- 個人成果：全員について `y_t({i})` を観測する（`i∈N`）。
- 未採用チーム `S∉X_t` の `y_t(S)` は観測しない。

乱数は共通乱数（比較公平性）のため、`t`・`S` ごとに事前生成し固定する。

## UD/DU 指標の定義と更新

全ての提携 `S∈X` について、累積カウンタを保持する：

- `up[S]`（初期0）
- `down[S]`（初期0）

各期 `t`、採用チーム `S∈X_t` についてのみ更新する（未観測比較は0カウント）。

更新規則：

- `|S|=1` は更新しない（`up/down` は常に0）。
- `|S|=2,3` のとき、各メンバー `k∈S` について個人成果 `y_t({k})` と比較し、
  - `y_t(S) > y_t({k})` なら `up[S] += 1`
  - `y_t({k}) > y_t(S)` なら `down[S] += 1`
  - 等しい場合は更新しない

## チーム編成アルゴリズム（共通形）

各期 `t`、未割当集合 `R := N` とし、`R` が空になるまで以下を繰り返す：

- `S ⊆ R` かつ `1 ≤ |S| ≤ 3` を選ぶ
- 採用後 `R := R \\ S`
- `X_t := X_t ∪ {S}`

同順位の候補が複数ある場合は乱択（乱数シード固定）。

## 3方式の仕様

候補集合を `Cand(R) = { S ⊆ R : 1 ≤ |S| ≤ 3 }` とする。

### UD設計

- `key_UD(S) = ( up[S], −down[S] )` を辞書順最大化。

### DU設計

- `key_DU(S) = ( down[S], −up[S] )` を辞書順最小化。

### Random設計

- `Cand(R)` から一様ランダムに選択。

## Oracle と Regret

分割 `P`（互いに素、合併が `N`）について、

```
OracleValue = max_P Σ_{S∈P} mu(S)
```

を定義し、Regret は `OracleValue − Total_t` とする。

OracleValue はビットマスクDPで計算する（`O(3*n^2*2^n)` 程度）。

## シミュレーション手順（全体）

前処理：

1. 入力：`n, T, d, seed`
2. `a_i, c_i, s_i(正規化), b_ij` を生成
3. `X` を列挙し `mu/cost/comp` を計算
4. `ε_t(S)` を `t=1..T, S∈X` について事前生成し固定
5. `OracleValue` をDPで計算

各方式（UD/DU/Random）を独立に実行：

1. `up/down` を初期化
2. 各期 `t`：
   - 貪欲に分割 `X_t` を作る
   - 観測：`S∈X_t` の `y_t(S)` と、全員の `y_t({i})`
   - `up/down` 更新（採用チームのみ）
   - `Total_t = Σ mu(S)`、`Regret_t = OracleValue − Total_t`、`TeamMuList_t` を記録

## 出力

- 指標A：`Total_t` 時系列
- 指標B：`Regret_t` 時系列
- 指標C：`mu(S)` の分布（全期サンプル）、min/median/max、分位点系列（例：10%, 25%）
